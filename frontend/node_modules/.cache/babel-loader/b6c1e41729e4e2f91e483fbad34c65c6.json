{"ast":null,"code":"import { id } from \"date-fns/locale\";\nimport Cookies from \"js-cookie\";\nimport qs from 'qs';\nconst BASEAPI = 'http://localhost:5000';\n\nconst apiFetchFile = async (endpoint, body) => {\n  // verifica se não tem um token junto no body (corpo da mensagem), neste caso ele busca\n  // nos Cookies pelo token e agrega junto no body\n  if (!body.token) {\n    let token = Cookies.get('token');\n\n    if (token) {\n      body.append = ('token', token);\n    }\n  } // cria uma constante de comunicação com o webservice envaindo o endereço (BASEAPI) + a rota (endpoint)\n  // enviando body para o webservice\n\n\n  const res = await fetch(BASEAPI + endpoint, {\n    method: 'POST',\n    body\n  }); // a const json recebe a resposta de um json vindo do webservice\n\n  const json = await res.json(); // se nessa resposta tiver um parâmetro chamado notallowed, é pq deu algum erro\n  // este notallowed vem do backend de um middlewares chamado Auth.js, que é o teste de privacidade de uma rota.\n\n  /* if (json.notallowed){\n       window.location.href = '/login';\n       return;\n   } */\n  // se não tiver o notallowed, a resposta do webservice é retornada\n\n  return json;\n}; // envaindo dados para o webservice via POST\n\n\nconst apiFetchPost = async (endpoint, body) => {\n  // verifica se não tem um token junto no body (corpo da mensagem), neste caso ele busca\n  // nos Cookies pelo token e agrega junto no body\n  if (!body.token) {\n    let token = Cookies.get('token');\n\n    if (token) {\n      body.token = token;\n    }\n  } // cria uma constante de comunicação com o webservice envaindo o endereço (BASEAPI) + a rota (endpoint)\n  // enviando os dados para o webservice\n\n\n  const res = await fetch(BASEAPI + endpoint, {\n    method: 'POST',\n    headers: {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(body)\n  }); // a const json recebe a resposta de um json vindo do webservice\n\n  const json = await res.json(); // se nessa resposta tiver um parâmetro chamado notallowed, é pq deu algum erro\n  // este notallowed vem do backend de um middlewares chamado Auth.js, que é o teste de privacidade de uma rota.\n\n  if (json.notallowed) {\n    window.location.href = '/login';\n    return;\n  } // se não tiver o notallowed, a resposta do webservice é retornada\n\n\n  return json;\n}; // o processo de GET é muito semelhante ao do POST, a diferença que uma URL é enviada para o webservice\n\n\nconst apiFetchGet = async (endpoint, body = []) => {\n  console.log(endpoint); // verifica se não tem um token junto no body (corpo da mensagem), neste caso ele busca\n  // nos Cookies pelo token e agrega junto no body\n\n  if (!body.token) {\n    let token = Cookies.get('token');\n\n    if (token) {\n      body.token = token;\n    }\n  } // cria a url e o fetch faz essa requisição\n\n\n  const res = await fetch(`${BASEAPI + endpoint}?${qs.stringify(body)}`); // o res passa a resposta json() para a const json\n\n  const json = await res.json(); // se nessa resposta tiver um parâmetro chamado notallowed, é pq deu algum erro\n  // este notallowed vem do backend de um middlewares chamado Auth.js, que é o teste de privacidade de uma rota.\n\n  if (json.notallowed) {\n    window.location.href = '/login';\n    return;\n  } // se não tiver o notallowed, a resposta do webservice é retornada\n\n\n  return json;\n}; // Esta API faz a conexão com as páginas, ela recebe os parâmetros vindo do HTML e envia para\n// o apiFetchPost ou apiFetchGet com a rota correta e os parâmetros que recebeu.\n\n\nconst AmorinhaAPI = {\n  login: async (email, password) => {\n    const json = await apiFetchPost('/user/login', {\n      email,\n      password\n    });\n    return json;\n  },\n  signup: async (name, email, password) => {\n    const json = await apiFetchPost('/user/signup', {\n      name,\n      email,\n      password\n    });\n    return json;\n  },\n  userInfo: async token => {\n    const json = await apiFetchPost('/user/info', {\n      token\n    });\n    return json;\n  },\n  // envia dados e arquivos. Tudo esta no array fData\n  addStudent: async fData => {\n    const json = await apiFetchFile('/student/add', fData);\n    return json;\n  },\n  searchStudent: async query_search => {\n    const json = await apiFetchGet('/student/list', query_search);\n    return json;\n  },\n  getStudent: async id => {\n    const json = await apiFetchGet('/student/info/:' + id);\n    return json;\n  },\n  editStudent: async fData => {\n    const json = await apiFetchFile('/student/edit/:' + id, fData);\n    return json;\n  },\n  getClasses: async () => {\n    const json = await apiFetchGet('/classes/list');\n    return json;\n  }\n};\nexport default (() => AmorinhaAPI); // addStudent: async (name, birthDate, responsableName, phone, emergencyWarning, phoneEmergency, foodRestriction, descriptionFoodRestriction, imageAuthorization, authorizedPeople, schoolClass, additionalNotes) => {\n//     const json = await apiFetchPost(\n//         '/student/add',\n//         {name, birthDate, responsableName, phone, emergencyWarning, phoneEmergency, foodRestriction, descriptionFoodRestriction, imageAuthorization, authorizedPeople, schoolClass, additionalNotes}\n//     );\n//     return json;\n// }","map":{"version":3,"sources":["/home/jael/Dropbox/devinhouse/front/react/amorinha/frontend/src/helpers/AmorinhaAPI.js"],"names":["id","Cookies","qs","BASEAPI","apiFetchFile","endpoint","body","token","get","append","res","fetch","method","json","apiFetchPost","headers","JSON","stringify","notallowed","window","location","href","apiFetchGet","console","log","AmorinhaAPI","login","email","password","signup","name","userInfo","addStudent","fData","searchStudent","query_search","getStudent","editStudent","getClasses"],"mappings":"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","sourcesContent":["import { id } from \"date-fns/locale\";\nimport Cookies from \"js-cookie\";\nimport qs from 'qs';\n\nconst BASEAPI = 'http://localhost:5000';\n\nconst apiFetchFile = async (endpoint, body) => {\n    // verifica se não tem um token junto no body (corpo da mensagem), neste caso ele busca\n    // nos Cookies pelo token e agrega junto no body\n    if (!body.token){\n        let token = Cookies.get('token');\n        if (token){\n            body.append = ('token', token);\n        }\n    }\n\n    // cria uma constante de comunicação com o webservice envaindo o endereço (BASEAPI) + a rota (endpoint)\n    // enviando body para o webservice\n    const res = await fetch(BASEAPI+endpoint, {\n        method:'POST',\n        body\n    });\n\n    // a const json recebe a resposta de um json vindo do webservice\n    const json = await res.json();\n    \n    // se nessa resposta tiver um parâmetro chamado notallowed, é pq deu algum erro\n    // este notallowed vem do backend de um middlewares chamado Auth.js, que é o teste de privacidade de uma rota.\n   /* if (json.notallowed){\n        window.location.href = '/login';\n        return;\n    } */\n\n    // se não tiver o notallowed, a resposta do webservice é retornada\n    return json;\n}\n\n// envaindo dados para o webservice via POST\nconst apiFetchPost = async (endpoint, body) => {\n\n    // verifica se não tem um token junto no body (corpo da mensagem), neste caso ele busca\n    // nos Cookies pelo token e agrega junto no body\n    if (!body.token){\n        let token = Cookies.get('token');\n        if (token){\n            body.token = token;\n        }\n    }\n\n    // cria uma constante de comunicação com o webservice envaindo o endereço (BASEAPI) + a rota (endpoint)\n    // enviando os dados para o webservice\n    const res = await fetch(BASEAPI+endpoint, {\n        method:'POST',\n        headers:{\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'\n        },\n        body:JSON.stringify(body)\n    });\n\n    // a const json recebe a resposta de um json vindo do webservice\n    const json = await res.json();\n    \n    // se nessa resposta tiver um parâmetro chamado notallowed, é pq deu algum erro\n    // este notallowed vem do backend de um middlewares chamado Auth.js, que é o teste de privacidade de uma rota.\n    if (json.notallowed){\n        window.location.href = '/login';\n        return;\n    }\n\n    // se não tiver o notallowed, a resposta do webservice é retornada\n    return json;\n}\n\n// o processo de GET é muito semelhante ao do POST, a diferença que uma URL é enviada para o webservice\nconst apiFetchGet = async (endpoint, body = []) => {\n    console.log(endpoint);\n    // verifica se não tem um token junto no body (corpo da mensagem), neste caso ele busca\n    // nos Cookies pelo token e agrega junto no body\n    if (!body.token){\n        let token = Cookies.get('token');\n        if (token){\n            body.token = token;\n        }\n    }\n\n    // cria a url e o fetch faz essa requisição\n    const res = await fetch(`${BASEAPI+endpoint}?${qs.stringify(body)}`);\n\n    // o res passa a resposta json() para a const json\n    const json = await res.json();\n\n    // se nessa resposta tiver um parâmetro chamado notallowed, é pq deu algum erro\n    // este notallowed vem do backend de um middlewares chamado Auth.js, que é o teste de privacidade de uma rota.\n    if (json.notallowed){\n        window.location.href = '/login';\n        return;\n    }\n\n    // se não tiver o notallowed, a resposta do webservice é retornada\n    return json;\n}\n\n// Esta API faz a conexão com as páginas, ela recebe os parâmetros vindo do HTML e envia para\n// o apiFetchPost ou apiFetchGet com a rota correta e os parâmetros que recebeu.\nconst AmorinhaAPI = {\n    login: async (email, password) => {\n        const json = await apiFetchPost(\n            '/user/login',\n            {email, password}\n        );\n        \n        return json;\n    },\n\n    signup: async (name, email, password) => {\n        const json = await apiFetchPost(\n            '/user/signup',\n            { name, email, password }\n        );\n\n        return json;\n    },\n\n    userInfo: async (token) => {\n        const json = await apiFetchPost(\n            '/user/info',\n            {token}\n        );\n\n        return json;\n    },\n\n    // envia dados e arquivos. Tudo esta no array fData\n    addStudent: async (fData) => {\n        const json = await apiFetchFile(\n            '/student/add',\n            fData\n        );\n\n        return json;\n    },\n\n    searchStudent: async (query_search) => {\n        const json = await apiFetchGet(\n            '/student/list',\n            query_search\n        );\n        \n        return json;\n    },\n\n    getStudent: async (id) => {\n        const json = await apiFetchGet(\n            '/student/info/:'+id,\n        );\n\n        return json;\n    },\n\n    editStudent: async (fData) => {\n        const json = await apiFetchFile(\n            '/student/edit/:'+id,\n            fData\n        );\n\n        return json;\n    },\n\n    getClasses: async () => {\n        const json = await apiFetchGet(\n            '/classes/list',\n        );\n\n        return json;\n    }\n\n};\n\nexport default () => AmorinhaAPI;\n\n\n// addStudent: async (name, birthDate, responsableName, phone, emergencyWarning, phoneEmergency, foodRestriction, descriptionFoodRestriction, imageAuthorization, authorizedPeople, schoolClass, additionalNotes) => {\n//     const json = await apiFetchPost(\n//         '/student/add',\n//         {name, birthDate, responsableName, phone, emergencyWarning, phoneEmergency, foodRestriction, descriptionFoodRestriction, imageAuthorization, authorizedPeople, schoolClass, additionalNotes}\n//     );\n\n//     return json;\n// }"]},"metadata":{},"sourceType":"module"}